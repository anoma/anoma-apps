module Counter.Simple.Increment;

import Stdlib.Prelude open;
import Anoma open;
import Anoma.State.CommitmentTree open;
import Applib.Helpers open;
import Applib.Identities open;
import Extra.Encoded open;

import Counter.Simple.Resource open;
import BaseLayer.TransactionRequest open;
import BaseLayer.ResourceMachine open;
import Extra.Tx open;

--- Increments the counter value by 1.
--- @param currentCounter The current counter to increment.
--- @param standardInputs The transaction function standard inputs.
--- @return The transaction object incrementing a counter.
increment
  (randSeed : Nat)
  (logic : Logic)
  (standardInputs : StandardInputs)
  (currentCounter : Resource)
  : Transaction :=
  runTx
    randSeed
    standardInputs
    do {
      nonce <- genRandomNonce;
      let
        newCounter :=
          mkCounter@{
            logic;
            nonce;
            count := Resource.value currentCounter + 1;
          };

      in
      pure
        prepareStandardTransaction@{
          standardInputs;
          consumed := [currentCounter];
          created := [newCounter];
        };
    };

main
  (logicEncoded : Encoded Logic)
  (currentCounterEncoded : Encoded Resource)
  (latestRoot : Nat)
  : TransactionRequest :=
  let
    logic := Encoded.decode logicEncoded;
    currentCounter := Encoded.decode currentCounterEncoded;
    std :=
      mkStandardInputs@{
        caller := Universal.identity;
        currentRoot := mkRoot latestRoot;
      };
  in increment 0 logic std currentCounter |> TransactionRequest.fromTransaction;
